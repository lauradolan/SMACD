using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using SMACD.Shared.Data;
using SMACD.Shared.Extensions;

namespace SMACD.Shared.Plugins.Scorers
{
    /// <summary>
    ///     Represents the output of a Plugin that understands how to process artifacts of that Plugin
    /// </summary>
    public abstract class Scorer : Plugin
    {
        private const string POINTER_FILE = ".ptr";

        protected Scorer(string workingDirectory)
        {
            WorkingDirectory = workingDirectory;
            if (File.Exists(Path.Combine(WorkingDirectory, POINTER_FILE)))
                PluginPointer =
                    ArtifactExtensions.LoadResultArtifact<PluginPointerModel>(Path.Combine(WorkingDirectory,
                        POINTER_FILE));

            Logger = Workspace.LogFactory.CreateLogger(GetType().Name);
        }

        /// <summary>
        ///     Pointer that generated this Scorer
        /// </summary>
        public PluginPointerModel PluginPointer { get; set; }

        /// <summary>
        ///     Directory holding artifacts generated by this Plugin
        /// </summary>
        public string WorkingDirectory { get; }
        
        /// <summary>
        ///     Execute any tasks that only need to run once during a summary operation
        /// </summary>
        /// <param name="summary">Summary document</param>
        /// <returns></returns>
        public virtual async Task GenerateScore(VulnerabilitySummary summary)
        {
            await Task.Yield();
        }

        /// <summary>
        ///     Get a try/catch-wrapped Task for score generation
        /// </summary>
        /// <param name="summary">Summary document</param>
        /// <returns></returns>
        internal Task GenerateScoreWrapped(VulnerabilitySummary summary)
        {
            return Task.Run(() =>
            {
                try
                {
                    GenerateScore(summary).Wait();
                }
                catch (Exception ex)
                {
                    Logger.LogCritical(ex, "Error generating score");
                }
            });
        }

        /// <summary>
        ///     Execute any tasks that run to converge the summary; that is, until all tasks
        ///     report making no changes to the summary in that generation
        /// </summary>
        /// <param name="summary">Summary document</param>
        /// <returns><c>TRUE</c> if changes were made, otherwise <c>FALSE</c></returns>
        public virtual async Task<bool> ConvergeSummary(VulnerabilitySummary summary)
        {
            return await Task.FromResult(false);
        }

        /// <summary>
        ///     Get a try/catch-wrapped Task for summary convergence
        /// </summary>
        /// <param name="summary">Summary document</param>
        /// <returns><c>TRUE</c> if changes were made, otherwise <c>FALSE</c></returns>
        internal Task<bool> ConvergeSummaryWrapped(VulnerabilitySummary summary)
        {
            return Task.Run(() =>
            {
                try
                {
                    return ConvergeSummary(summary).Result;
                }
                catch (Exception ex)
                {
                    Logger.LogCritical(ex, "Error converging summary");
                }

                return false;
            });
        }
    }
}